// 给定一个数据流，长度为N，到终点前不知道有多大
// 用O(N)时间取出M个数据，每个数据被选中的概率一样(随机)

function random(m, n) {
  // 不足m个则全选
  if (m > n) return new Array(n).fill(0).map((_, index) => index);
  // 把前m个都放进去
  let selected = new Array(m).fill(-1);
  for (let i = 0; i < m; i++) {
    selected[i] = i;
  }

  // 后续的，每次生成随机数如果比m小，则替换数据
  for (let i = m; i < n; i++) {
    let rand = (Math.random() * (i + 1)) | 0;
    if (rand < m) selected[rand] = i;
  }

  return selected;
}

for (let i = 0; i < 10; i++) {
  console.log(i, ">", random(10, 100));
}

// 原理
// 一、简单化 5行文本选出一行
// a. 第一行出现时，只有1个，则等概率为1
// b. 第二行出现时，选第二行的概率为1/2，此时第一行应该为未选中，它在a.中概率为1，在b.中且未选中的概率为1/2，因此它的概率更新为1 * 1/2 = 1/2
// c. 第三行出现时，选第三行的概率为1/3，此时第一行应该为未选中，它在b.中概率为1/2，在c.中且未选中的概率为2/3，因此它的概率更新为1/2 * 2/3 = 1/3，第二行同理也为1/3
// d. 第四行出现时，选第四行的概率为1/4，此时前面三行未选中3/4，但他们在第四行出现之前的选中概率为1/3，因此在第四行，它们的概率更新为3/4 * 1/3 = 1/4
// e. ....
//
// 你可能发现了这其中的规律
// 是的
// 1 * 1/2 * 2/3 * 3/4 * ... * (n - 1)/n = 1/n;
//
// 二、推论到m n的例子，其实也是一样的
//
// 比如4, 10组合
// 1 * 1 * 1 * 1 * 4/5 * 5/6 * 6/7 * 7/8 * 8/9 * 9/10 = 4/10
//
// 三、再推论到多线程处理
// k台机器从N中选m个数 从k个流里面
// k台机器实际上就把N划分为了0...n1....n2....n3...n
// 1. 从[0,n]生成一个随机数
// [0,n1]中只取[0,n1]的数字
// [n1,n2]中只取[n1,n2]的数字
// ...
// 则一次取出一条数据
// 2. 重复m次则选出m条数据
//
